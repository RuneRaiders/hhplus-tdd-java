# **동시성 제어(Concurrency Control)**
이 보고서를 통해, 저는 동시성 제어의 개념은 무엇이고, 
동시성 문제가 발생하는 원인, 동시성 제어의 방식 및 각 방식의 장/단점을 알아보고자 합니다. 

## **1. 동시성 제어(Concurrency Control)란?**

### **1) 프로세스(Process)와 스레드(Thread)**
프로세스는 실행 중인 프로그램을 의미한다.
프로그램이 실제로 실행되어, 메모리나 CPU와 같은 자원을 할당받으면, 이를 프로세스라고 부른다.
프로세스는 독자적인 메모리를 할당받기 때문에, 프로세스끼리 일반적으로 서로의 메모리 영역을 침범하지 못한다.
스레드는 프로세스 내에서 실행되는 최소 단위로, 하나의 프로세스가 여러 개의 스레드를 가질 수 있다는 점에서
동시성(Concurrency)이라는 특징을 가지고 있다.

### **2) 병렬 프로그래밍의 장/단점**
프로세스 내부의 스레드들은 같은 자원을 공유하여 사용이 가능하다.
이러한 점은 스레드 간 데이터 교환이 상대적으로 빠르고 효율적이라는 장점을 가지고 있다.
하지만, 각 스레드가 같은 자원을 공유하고 있다는 점에서 스레드 간 경쟁 상태가 발생할 수 있고,
이는 동시성 문제로 이어진다.

### **3) 동시성 제어**
따라서, 동시성 제어는 데이터의 일관성과 정합성을 보장하면서,
프로세스 내 각 스레드가 공유자원에 접근할 때 발생할 수 있는 경쟁 조건(race condition)이나 데드락(deadlock) 같은
문제를 방지하는 것이다.

---

## **2. 동시성 문제의 원인**

### **1) 경쟁 조건(Race Condition)**
여러 스레드가 동시에 같은 자원을 수정하고자 할 때, 타이밍이나 접근 순서에 따라 실행결과가 달라지는 상황을 말한다.

### **2) 교착 상태(Deadlock)**
공유 자원에 대한 요구가 엉켜서, 프로세스나 스레드가 자원의 락(Lock)을 획득하기 위해 무한 대기하는 것을 말한다.
이러한 교착 상태가 발생할 수 있는 조건은 다음과 같다.

**a. 상호 배제(Mutual Exclusion)**\
경쟁 조건(Race Condition)의 문제를 해결하기 위해, 한 자원에 한 스레드만 접근할 수 있게 하는 것이다.

**b. 점유 상태로 대기(Hold and Wait)**\
공유 자원에 락(Lock)을 획득하여 점유 중인 상태에서, 다른 자원의 락(Lock)을 획득하기 위해 대기하고 있는 상황을 말한다.

**c. 선점 불가(No Preemption)**\
다른 프로세스나 스레드가 자원을 선점하고 있어, 그 자원을 뺏어올 방법이 없는 상태를 말한다.

**d. 순환성 대기(Circular Wait)**\
점유 상태로 대기(Hold and Wait)가 순환적으로 구조를 가지고 있는 것을 말한다. 이러한 구조가 계속 발생할 경우, 모든 프로세스가 무한 대기에 놓일 수 있다.

### **3) 기아(Starvation)**
스레드 간 우선순위를 부여하여 공유 자원에 접근할 때, 우선순위가 낮은 스레드가 소외되어 접근 기회를 얻지 못하는 상태를 말한다.
우선순위가 높은 스레드들이 번갈아가며 계속하여 공유 자원에 접근하게 되면, 우선순위가 낮은 스레드는 자원에 접근하기 위해 대기하고 있음에도 우선순위가 높은 스레드가 재접근 시 양보를 해야 하기 때문이다.

### **4) 무한 대기(LiveLock)**
스레드들의 동시 실행 간, 락의 해제와 획득이 반복적으로 이루어지면서, 정상적으로 작동하는 것처럼 보이지만 서로가 서로를 방해하며 사실상 아무것도 하지 못하고 무한 동작 중인 상황을 말한다.

---

## **3. 동시성 제어의 방식**

### **1) synchronized**
synchronized 키워드를 통해서, 해당 블럭의 엑세스를 동기화할 수 있다.
synchronized가 선언된 블럭에는 동시에 하나의 스레드만 접근할 수 있게 하는 것이다.
하지만, 이러한 방식의 경우 멀티 스레드의 장점인 스레드 간 데이터 교환의 효율성을 저해하게 되고,
단일 JVM이 아닌 멀티 서버 환경에서는 동시성을 보장할 수 없다는 단점을 지니게 된다.

### **2) volatile**
volatile 키워드는 Java 내 변수에 대해 CPU Cache가 아닌 Main Memory에 저장하겠다고 명시하는 것을 말한다.
volatile 변수는 한 스레드가 해당 변수 값을 변경하면, 다른 스레드는 그 변경된 값을 바로 반영하기에,
가시성(Visibility) 문제를 해결할 수 있다는 장점을 가지고 있다.
하지만, 단일 읽기/쓰기 연산에 대해서만 원자성(Atomicity)을 보장하기에, 복합적인 연산(ex.i++)에 대해서는 원자성(Atomicity)을 보장하지 않는다.
또한, 스레드 간의 동기화(Synchronization)를 강제하지 않기 때문에,
여러 스레드의 복잡한 작업이 동시에 이루어질 때에는 synchronized, ReentrantLock 등의 동기화 메커니즘을 사용하여 스레드 간의 경합 조건을 방지해야 한다.

### **3) Atomic**
Atomic 키워드는 Java에서 제공하는 원자적 연산을 제공하는 클래스들을 말한다.
단일 연산에 대해 원자적으로 처리하기 때문에, 연산 중 다른 스레드의 개입을 막아 경합 상태를 피할 수 있게 하며,
synchronized와 달리 락(Lock)을 사용하지 않기에 락 경쟁(Lock Contention)을 피할 수 있어 성능이 향상될 수 있다.
또한 CAS(Compare and Swap)라는 기법을 사용하는데, 값을 비교 후 교환하는 방식이기에 락(Lock)을 사용하지 않고 동시성 제어를 할 수 있다.
하지만, Atomic 역시 단일 변수에 대한 단순 연산에 대해서만 원자성을 보장하고, 단일 JVM이 아닌 멀티 서버 환경에서는 동시성을 보장할 수 없다는 단점을 지니게 된다.

### **4) ReentrantLock**
ReentrantLock 키워드는 synchronized보다 더 세밀하게 락(Lock)을 제어할 수 있다.
CPU Cache와 Main Memory간의 동기화를 명시적으로 제어할 수 있다는 장점을 가지고 있지만,
락(Lock)을 명시적으로 해제해야 하므로, unlock() 미호출 시, 데드락(Deadlock)이 발생할 수 있다.
또한 세밀하게 락(Lock)을 제어해야 한다는 점에서 복잡성을 가지고 있기 때문에,
JVM이 내부적으로 최적화된 방식으로 락을 관리하는 synchronized에 비해 성능 비용이 더 많이 발생할 수 있다.

